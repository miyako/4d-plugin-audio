/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Audio
 #	author : miyako
 #	2017/03/10
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

#include "AudioCapture.h"

#include <CoreServices/CoreServices.h>
#include <CoreAudio/CoreAudio.h>

//#include <CoreMedia/CoreMedia.h>//10.7
#import <QTKit/QTKit.h>//10.6

#import <AudioUnit/AudioUnit.h>
#import <AudioToolbox/AudioToolbox.h>

#include "AudioDeviceList.h"
#include "CAStreamBasicDescription.h"

AudioCapture *capture;

std::map<uint32_t, NSSound*> soundFileRefs;

// --- soundFileRefs

void _soundFileRefCreate(C_TEXT &path, C_LONGINT &index){
	
	unsigned int i = 0;
	
	NSURL *url = path.copyUrl();
	
	if(url){
		NSSound *sound = [[NSSound alloc]initWithContentsOfURL:url byReference:YES];
		[url release];
		i++;
		while (soundFileRefs.find(i) != soundFileRefs.end()) {
			i++;
		}
		soundFileRefs.insert(std::map<uint32_t, NSSound*>::value_type(i, sound));
		
	}
	
	index.setIntValue(i);
}

void _soundFileRefDelete(C_LONGINT &index){
	
	NSSound *sound = nil;
	
	std::map<uint32_t, NSSound*>::iterator pos = soundFileRefs.find(index.getIntValue());
	
	if(pos != soundFileRefs.end()) {
		sound = pos->second;
		[sound stop];
		[sound release];
		soundFileRefs.erase(pos);
	}
	
}

NSSound *_soundFileRefGet(C_LONGINT &index){
	
	NSSound *sound = nil;
	
	std::map<uint32_t, NSSound*>::iterator pos = soundFileRefs.find(index.getIntValue());
	
	if(pos != soundFileRefs.end()) {
		sound = pos->second;
	}
	
	return sound;
}

#pragma mark -

void CommandDispatcherInMainProcess (int32_t pProcNum, PA_PluginParameters params)
{
	switch(pProcNum)
	{
			// --- Record
		case 2 :
			PA_RunInMainProcess((PA_RunInMainProcessProcPtr)AUDIO_End_recording, params);
			break;
			
		case 3 :
			PA_RunInMainProcess((PA_RunInMainProcessProcPtr)AUDIO_Begin_recording, params);
			break;
			
		case 4 :
			PA_RunInMainProcess((PA_RunInMainProcessProcPtr)AUDIO_Is_recording, params);
			break;
			
			// --- Convert
			
		case 15 :
			PA_RunInMainProcess((PA_RunInMainProcessProcPtr)AUDIO_Convert, params);
			break;
	}
}

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		switch(pProcNum)
		{
			case 2 :
			case 3 :
			case 4 :
			case 15 :
				CommandDispatcherInMainProcess (pProcNum, params);
				break;
			default:
				CommandDispatcher(pProcNum, pResult, pParams);
				break;
		}
		
	}
	catch(...)
	{

	}
}

#pragma mark -

bool IsProcessOnExit()
{
	C_TEXT name;
	PA_long32 state, time;
	PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
	CUTF16String procName(name.getUTF16StringPtr());
	CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
	return (!procName.compare(exitProcName));
}

void OnStartup()
{
	capture = NULL;
}

void OnCloseProcess()
{
	if(IsProcessOnExit())
	{
		if(capture) [capture release];
	}
}

#pragma mark -

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
		case kInitPlugin :
		case kServerInitPlugin :
			OnStartup();
			break;
			
		case kCloseProcess :
			OnCloseProcess();
			break;
			
// --- Devices

		case 1 :
			AUDIO_DEVICE_LIST(pResult, pParams);
			break;

// --- Play

		case 5 :
			AUDIO_Open_file(pResult, pParams);
			break;

		case 6 :
			AUDIO_CLOSE(pResult, pParams);
			break;

		case 7 :
			AUDIO_PLAY(pResult, pParams);
			break;

		case 8 :
			AUDIO_PAUSE(pResult, pParams);
			break;

		case 9 :
			AUDIO_RESUME(pResult, pParams);
			break;

		case 10 :
			AUDIO_STOP(pResult, pParams);
			break;

		case 11 :
			AUDIO_Is_playing(pResult, pParams);
			break;

		case 12 :
			AUDIO_Get_duration(pResult, pParams);
			break;

		case 13 :
			AUDIO_Get_time(pResult, pParams);
			break;

		case 14 :
			AUDIO_SET_TIME(pResult, pParams);
			break;
	}
}

#pragma mark Devices

// ------------------------------------ Devices -----------------------------------

void BuildDeviceList(AudioDeviceList *devlist, ARRAY_TEXT *names, ARRAY_LONGINT *ids)
{
	names->setSize(1);
	ids->setSize(1);
	
	AudioDeviceList::DeviceList &thelist = devlist->GetList();
	
	for (AudioDeviceList::DeviceList::iterator i = thelist.begin(); i != thelist.end(); ++i) {
		names->appendUTF8String((const uint8_t *)(*i).mName, strlen((*i).mName));
		ids->appendIntValue((*i).mID);
	}
}

void AUDIO_DEVICE_LIST(sLONG_PTR *pResult, PackagePtr pParams)
{
	ARRAY_TEXT Param1;
	ARRAY_LONGINT Param2;
	C_LONGINT Param3;
	
	Param3.fromParamAtIndex(pParams, 3);
	
	AudioDeviceID audioDeviceId;
	
	bool isInput = (!Param3.getIntValue());
	
	AudioDeviceList *audioDeviceList = new AudioDeviceList(isInput);
	
	UInt32 propsize = sizeof(AudioDeviceID);
	AudioObjectPropertyAddress theAddress;
	
	theAddress.mSelector = isInput ? kAudioHardwarePropertyDefaultInputDevice : kAudioHardwarePropertyDefaultOutputDevice;
	theAddress.mScope = kAudioObjectPropertyScopeGlobal;
	theAddress.mElement = kAudioObjectPropertyElementMaster;
	
	propsize = sizeof(AudioDeviceID);
	
	verify_noerr (AudioObjectGetPropertyData(kAudioObjectSystemObject,
																					 &theAddress,
																					 0,
																					 NULL,
																					 &propsize,
																					 &audioDeviceId));
	
	BuildDeviceList(audioDeviceList, &Param1, &Param2);
	
	delete audioDeviceList;
	
	Param1.toParamAtIndex(pParams, 1);
	Param2.toParamAtIndex(pParams, 2);
}

#pragma mark Recording

// ----------------------------------- Recording ----------------------------------

void AUDIO_End_recording(PA_PluginParameters params)
{
	sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
	
	C_TEXT returnValue;
	
	if (capture) {
		returnValue.setPath([capture outputFile]);
		[capture release];
		capture = NULL;
	}
	
	returnValue.setReturn(pResult);
}

void AUDIO_Is_recording(PA_PluginParameters params)
{
	sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
	
	C_LONGINT returnValue;
	
	if (capture)
		returnValue.setIntValue([capture isRecording]);
	
	returnValue.setReturn(pResult);
}

void AUDIO_Begin_recording(PA_PluginParameters params)
{
	sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
	PackagePtr pParams = (PackagePtr)params->fParameters;
	
	C_TEXT Param1;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	if(capture) [capture release];
	
	NSString *path = Param1.copyPath();
	
	capture = [[AudioCapture alloc]initWithPath:path];
	
	if([capture isRunning]){
		[capture setRecording:YES];
		returnValue.setIntValue(1);
	}
	
	[path release];
	
	returnValue.setReturn(pResult);
}

#pragma mark Play

// ------------------------------------- Play -------------------------------------

void AUDIO_Open_file(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	_soundFileRefCreate(Param1,returnValue);
	
	returnValue.setReturn(pResult);
}

void AUDIO_CLOSE(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	_soundFileRefDelete(Param1);
}

void AUDIO_PLAY(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	NSSound *sound = _soundFileRefGet(Param1);
	
	if(sound)
		[sound play];
}

void AUDIO_PAUSE(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	NSSound *sound = _soundFileRefGet(Param1);
	
	if(sound)
		[sound pause];
}

void AUDIO_RESUME(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	NSSound *sound = _soundFileRefGet(Param1);
	
	if(sound)
		[sound resume];
}

void AUDIO_STOP(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	NSSound *sound = _soundFileRefGet(Param1);
	
	if(sound)
		[sound stop];
}

void AUDIO_Is_playing(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	NSSound *sound = _soundFileRefGet(Param1);
	
	if(sound)
		returnValue.setIntValue([sound isPlaying]);
	
	returnValue.setReturn(pResult);
}

void AUDIO_Get_duration(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_TIME returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	NSSound *sound = _soundFileRefGet(Param1);
	
	if(sound)
		returnValue.setSeconds([sound duration]);
	
	returnValue.setReturn(pResult);
}

void AUDIO_Get_time(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_TIME returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	NSSound *sound = _soundFileRefGet(Param1);
	
	if(sound)
		returnValue.setSeconds([sound currentTime]);
	
	returnValue.setReturn(pResult);
}

void AUDIO_SET_TIME(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_TIME Param2;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	NSSound *sound = _soundFileRefGet(Param1);
	
	if(sound)
		[sound setCurrentTime:Param2.getSeconds()];
}

#pragma mark Convert

// ------------------------------------ Convert -----------------------------------

bool GetFormatFromFileId (AudioFileID fileId, CAStreamBasicDescription &format)
{
	UInt32 size;
	bool success = false;
	
	if(!AudioFileGetPropertyInfo(fileId,
															 kAudioFilePropertyFormatList,
															 &size, NULL)){
		
		UInt32 numFormats = size / sizeof(AudioFormatListItem);
		AudioFormatListItem *formatList = new AudioFormatListItem [numFormats];
		
		if(!AudioFileGetProperty(fileId,
														 kAudioFilePropertyFormatList,
														 &size,
														 formatList)){
			
			numFormats = size / sizeof(AudioFormatListItem); // we need to reassess the actual number of formats when we get it
			
			if (numFormats == 1) {
				// this is the common case
				format = formatList[0].mASBD;
				success = true;
			} else {
				// we should look to see which decoders we have on the system
				if(!AudioFormatGetPropertyInfo(kAudioFormatProperty_DecodeFormatIDs, 0, NULL, &size)){
					UInt32 numDecoders = size / sizeof(OSType);
					OSType *decoderIDs = new OSType [ numDecoders ];
					if(!AudioFormatGetProperty(kAudioFormatProperty_DecodeFormatIDs, 0, NULL, &size, decoderIDs)){
						unsigned int i = 0;
						for (; i < numFormats; ++i) {
							OSType decoderID = formatList[i].mASBD.mFormatID;
							bool found = false;
							for (unsigned int j = 0; j < numDecoders; ++j) {
								if (decoderID == decoderIDs[j]) {
									found = true;
									break;
								}
							}
							if (found) break;
						}
						delete [] decoderIDs;
						
						if (!(i >= numFormats)) {
							format = formatList[i].mASBD;
							success = true;
						}
						
					}
				}
			}
			delete [] formatList;
		}
	}
	return success;
}

bool GetFormatFromPath(C_TEXT &path, CAStreamBasicDescription &format){
	
	bool success = false;
	NSURL *url = path.copyUrl();
	
	if(url){
		AudioFileID fileId;
		if(!AudioFileOpenURL((CFURLRef)url, kAudioFileReadPermission, 0, &fileId)){
			success = GetFormatFromFileId (fileId, format);
			AudioFileClose (fileId);
		}
		[url release];
	}
	return success;
}

AudioStreamBasicDescription AudioFormatAAC(){
	
	AudioStreamBasicDescription audioFormat;
	audioFormat.mSampleRate         = 44100.0;
	audioFormat.mFormatID           = kAudioFormatMPEG4AAC;
	audioFormat.mFormatFlags        = 0;
	audioFormat.mBytesPerPacket     = 0;
	audioFormat.mFramesPerPacket    = 1024;
	audioFormat.mBytesPerFrame      = 0;
	audioFormat.mChannelsPerFrame   = 2;
	audioFormat.mBitsPerChannel     = 0;
	audioFormat.mReserved           = 0;
	
	return audioFormat;
}

AudioFileTypeID GetFileType(C_LONGINT &param){
	
	AudioFileTypeID outputFileType;
	
	switch (param.getIntValue()) {
		case 1:
			outputFileType = kAudioFileMP3Type;
			break;
		default:
			outputFileType = kAudioFileAAC_ADTSType;
			break;
	}
	
	return outputFileType;
}

void AUDIO_Convert(PA_PluginParameters params)
{
	sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
	PackagePtr pParams = (PackagePtr)params->fParameters;
	
	C_TEXT Param1;
	C_TEXT Param2;
	C_REAL Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	
	ExtAudioFileRef infile, outfile;
	
	OSStatus err = noErr;
	
	CAStreamBasicDescription inputFormat, outputFormat;
	
	if(GetFormatFromPath(Param1, inputFormat)){
		
		NSURL *url = Param1.copyUrl();
		Float64 outputSampleRate = Param3.getDoubleValue();
		
		if(url){
			err = ExtAudioFileOpenURL ((CFURLRef)url, &infile);
			[url release];
			
			if(!err){
				
				outputFormat = AudioFormatAAC();
				AudioFileTypeID outputFileType = kAudioFileAAC_ADTSType;
				outputFormat.mSampleRate = (outputSampleRate == 0 ? inputFormat.mSampleRate : outputSampleRate);
				outputFormat.mChannelsPerFrame = (outputFormat.mFormatID == kAudioFormatiLBC ? 1 : inputFormat.NumberChannels()); // for iLBC num channels must be 1
				
				url = Param2.copyUrl();
				
				if(url){
					err = ExtAudioFileCreateWithURL ((CFURLRef)url,
																					 outputFileType,
																					 &outputFormat,
																					 NULL,
																					 kAudioFileFlags_EraseFile,
																					 &outfile);
					[url release];
					
					if(!err){
						
						CAStreamBasicDescription clientFormat = (inputFormat.mFormatID == kAudioFormatLinearPCM ? inputFormat : outputFormat);
						UInt32 size = sizeof(clientFormat);
						if(!ExtAudioFileSetProperty(infile, kExtAudioFileProperty_ClientDataFormat, size, &clientFormat)){
							
							size = sizeof(clientFormat);
							if(!ExtAudioFileSetProperty(outfile, kExtAudioFileProperty_ClientDataFormat, size, &clientFormat)){
								
								AudioConverterRef outConverter;
								size = sizeof(outConverter);
								if(!ExtAudioFileGetProperty(outfile, kExtAudioFileProperty_AudioConverter, &size, &outConverter)){
									
									CFArrayRef config = NULL;
									if(!ExtAudioFileSetProperty(outfile,
																							kExtAudioFileProperty_ConverterConfig,
																							sizeof(config),
																							&config)){
										
										const UInt32 kSrcBufSize = 32768;
										char srcBuffer[kSrcBufSize];
										
										while (1)
										{
											PA_YieldAbsolute();
											
											AudioBufferList fillBufList;
											fillBufList.mNumberBuffers = 1;
											fillBufList.mBuffers[0].mNumberChannels = inputFormat.mChannelsPerFrame;
											fillBufList.mBuffers[0].mDataByteSize = kSrcBufSize;
											fillBufList.mBuffers[0].mData = srcBuffer;
											
											UInt32 numFrames = (kSrcBufSize / clientFormat.mBytesPerFrame);
											
											if(!ExtAudioFileRead (infile, &numFrames, &fillBufList)){
												
												if (!numFrames){
													returnValue.setIntValue(1);
													break;
												}
												
												if(ExtAudioFileWrite(outfile, numFrames, &fillBufList))
													break;
											}
										}
									}
								}
							}
						}
						ExtAudioFileDispose(outfile);
					}
				}
				ExtAudioFileDispose(infile);	
			}
		}	
	}
	
	returnValue.setReturn(pResult);
}

